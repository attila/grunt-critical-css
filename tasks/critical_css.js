/**
 * grunt-critical-css
 * https://github.com/attilab/grunt-critical-css
 *
 * Copyright (c) 2015 Attila Beregszaszi
 * Licensed under the MIT license.
 */

module.exports = function(grunt) {

  var criticalCss = require('critical-css');

  grunt.registerMultiTask('critical_css', 'Grunt task to extract Above the Fold CSS for a URL', function() {
    if (!this.data.url) {
      throw new TypeError('Missing url parameter.');
    }
    if (!this.data.dest) {
      throw new TypeError('Missing dest parameter.');
    }
    if (grunt.util.kindOf(this.data.url) !== 'string' && grunt.util.kindOf(this.data.url) !== 'array') {
      throw new TypeError('url should be a string or an array.');
    }

    var done = this.async();

    // Merge task-specific and/or target-specific options with these defaults.
    var options = this.options({
      width: 1200,
      height: 900,
      excludeSelectors: [],
      enabledOrigins: [],
      keepInlineStyles: false,
      ignoreConsole: true,
      maxBuffer: 800*1024,
      sizes: []
    });
    var dest = this.data.dest;
    var urls = [];
    var out = '';

    // Convert url to an array if a single url was given.
    switch (grunt.util.kindOf(this.data.url)) {
      case 'string':
        urls.push(this.data.url);
        break;
      case 'array':
        urls = this.data.url;
        break;
    }
    // Convert browser size to an array in sizes if only width and height are given.
    if (!options.sizes.length) {
      var obj = {};
      obj[options.width + 'x' + options.height] = '';
      options.sizes.push(obj);
    }

    /**
     * Execute criticalCss on a collection of browser sizes using recursion.
     */
    function runSizes(i) {
      if (i < options.sizes.length) {
        var key = Object.keys(options.sizes[i])[0];
        var size = key.split('x');
        var mq = options.sizes[i][key] || undefined;

        options.width = size[0];
        options.height = size[1];

        runUrls(0, options.width, options.height, mq, function() {
          runSizes(++i);
        });
      }
      else {
        finalise();
      }
    }

    /**
     * Execute criticalCss on a collection of URLs using recursion.
     */
    function runUrls(k, width, height, mq, cb) {
      if (k < urls.length) {
        criticalCss.generate(urls[k], options, function(err, output) {
          if (err) {
            grunt.log.error(urls[k]);
            grunt.fail.fatal(err.message);
          }
          else {
            processStep(output, urls[k], width, height, mq);

            runUrls(k + 1, width, height, mq, cb);
          }
        });
      }
      else {
        if (typeof cb === 'function') {
          cb.apply(this);
        }
      }
    }

    /**
     * Append the result of a single URL.
     */
    function processStep(output, url, width, height, mq) {
      if (mq) {
        output = '@media '+ mq + ' {\u000a' + output + '}\u000a';
      }

      out += '/* Generated by critical-css.js Browser size [' + width + 'x' + height  + '] on ' + url + ' */\u000a' + output;

      grunt.log.ok('[' + width + 'x' + height + '] ' + url);
    }

    /**
     * Write the file with all the results.
     */
    function finalise() {
      grunt.file.write(dest, out);
      grunt.log.ok('Output written to: "' + dest +'".');
      done();
    }

    // Execute.
    runSizes(0);
  });
};
