/**
 * grunt-critical-css
 * https://github.com/attilab/grunt-critical-css
 *
 * Copyright (c) 2015 Attila Beregszaszi
 * Licensed under the MIT license.
 */

module.exports = function(grunt) {

  var criticalCss = require('critical-css');

  grunt.registerMultiTask('critical_css', 'Grunt task to extract Above the Fold CSS for a URL', function() {
    if (!this.data.url) {
      throw new TypeError('Missing url parameter.');
    }
    if (!this.data.dest) {
      throw new TypeError('Missing dest parameter.');
    }
    if (grunt.util.kindOf(this.data.url) !== 'string' && grunt.util.kindOf(this.data.url) !== 'array') {
      throw new TypeError('url should be a string or an array.');
    }

    var done = this.async();

    // Merge task-specific and/or target-specific options with these defaults.
    var options = this.options({
      width: 1200,
      height: 900,
      excludeSelectors: [],
      enabledOrigins: [],
      keepInlineStyles: false,
      ignoreConsole: true,
      maxBuffer: 800*1024,
      sizes: []
    });
    var dest = this.data.dest;
    var urls = [];
    var buffer = '';
    var urlsBuffer = '';

    // Convert url to an array if a single url was given.
    switch (grunt.util.kindOf(this.data.url)) {
      case 'string':
        urls.push(this.data.url);
        break;
      case 'array':
        urls = this.data.url;
        break;
    }
    // Convert browser size to an array in sizes if only width and height are given.
    if (!options.sizes.length) {
      var obj = {};
      obj[options.width + 'x' + options.height] = '';
      options.sizes.push(obj);
    }

    /**
     * Execute critical-css on a collection of browser sizes using recursion.
     */
    function runSizes(i) {
      if (i === 0) {
        grunt.verbose.writeln('runSizes(): Emptying buffer on start.');
        buffer = '';
      }

      if (i < options.sizes.length) {
        var key = Object.keys(options.sizes[i])[0];
        var size = key.split('x');
        var mq = options.sizes[i][key] || undefined;

        options.width = size[0];
        options.height = size[1];

        runUrls(0, options.width, options.height, function(out) {
          grunt.verbose.writeln('runSizes() [callback]: out.length: ', out.length);
          buffer += processStepSize(out, options.width, options.height, mq);

          // Recursion: run self again until all the sizes are processed.
          runSizes(++i);
        });
      }
      else {
        finalise(buffer);
      }
    }

    /**
     * Execute criticalCss on a collection of URLs using recursion.
     */
    function runUrls(k, width, height, cb) {
      if (k === 0) {
        grunt.verbose.writeln('runUrls(): Emptying urlsBuffer on start.');
        urlsBuffer = '';
      }

      if (k < urls.length) {
        criticalCss.generate(urls[k], options, function(err, output) {
          if (err) {
            grunt.log.error(urls[k]);
            grunt.fail.fatal(err.message);
          }
          else {
            urlsBuffer += processStepUrl(output, urls[k], width, height);

            // Recursion: run self again until all the URLs are processed.
            runUrls(++k, width, height, cb);
          }
        });
      }
      else {
        if (typeof cb === 'function') {
          cb.apply(this, [urlsBuffer]);
        }
      }
    }

    /**
     * Append the result of a single URL.
     */
    function processStepSize(output, width, height, mq) {
      if (mq) {
        output = '@media '+ mq + ' {\u000a' + output + '}\u000a';
      }
      else {
        output = output + '\u000a';
      }
      grunt.log.ok('[' + width + 'x' + height + '] ' + (mq ? '@media '+ mq : 'no media query'));

      return output;
    }

    /**
     * Append the result of a single URL.
     */
    function processStepUrl(output, url, width, height) {
      var ret = '\u000a/* Generated by critical-css.js Browser size [' + width + 'x' + height  + '] on ' + url + ' */\u000a' + output;
      grunt.log.ok('[' + width + 'x' + height + '] ' + url);

      return ret;
    }

    /**
     * Write the file with all the results.
     */
    function finalise(buffer) {
      // @todo dedupe the output
      // @see http://stackoverflow.com/questions/9229645/remove-duplicates-from-javascript-array
      grunt.file.write(dest, buffer);
      grunt.log.ok('Output written to: "' + dest +'".');
      done();
    }

    // Execute.
    runSizes(0);
  });
};
